/*"C:/JAVA/IMAGENES/EIBSFrame2805copia1.3/Prueba de Pixelado.png"
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package imagenes;

import java.awt.Color;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author gabest
 */
public class ImgPrincipal114 extends javax.swing.JFrame {

 

    //File ruta = new File("C:/Users/gabest/Pictures");
    //1-agregado el 12-4
    File ruta = new File("");
    
    public ImgPrincipal114() {
        
        initComponents();
        this.setExtendedState(MAXIMIZED_BOTH);
        
        //1-agregado el 12-4
        ruta = new File("C:/Users/gabest/Pictures");
        
             
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenu5 = new javax.swing.JMenu();
        jMenu6 = new javax.swing.JMenu();
        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        txtNombreArchivo = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();
        jTextField3 = new javax.swing.JTextField();
        txtTotPix = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jLabel21 = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        mAbrir = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenu3 = new javax.swing.JMenu();
        miPixelar = new javax.swing.JMenuItem();
        Sectorizar = new javax.swing.JMenuItem();
        miEscalaGrises = new javax.swing.JMenuItem();
        jMenu7 = new javax.swing.JMenu();

        jMenuItem1.setText("jMenuItem1");

        jMenu5.setText("jMenu5");

        jMenu6.setText("jMenu6");

        jLabel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("EIBSFrame2805copiaBeta1.5");

        jPanel1.setBackground(new java.awt.Color(204, 255, 255));

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel3.setText("Imagen");

        jLabel5.setText("Nombre");

        txtNombreArchivo.setEditable(false);

        jLabel6.setText("Ancho");

        jLabel7.setText("Alto");

        jTextField2.setEditable(false);

        jTextField3.setEditable(false);

        txtTotPix.setEditable(false);

        jLabel11.setText("Total Pixels");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(26, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel11)
                        .addGap(18, 18, 18)
                        .addComponent(txtTotPix, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(29, 29, 29))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel5)
                            .addComponent(jLabel6))
                        .addGap(18, 18, 18)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 91, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(jPanel1Layout.createSequentialGroup()
                                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGap(18, 18, 18)
                                    .addComponent(jLabel7)
                                    .addGap(18, 18, 18)
                                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addComponent(txtNombreArchivo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(4, 4, 4)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtNombreArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel6)
                    .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txtTotPix, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel11))
                .addContainerGap(18, Short.MAX_VALUE))
        );

        txtNombreArchivo.getAccessibleContext().setAccessibleName("");

        jLabel21.setBackground(new java.awt.Color(255, 255, 255));

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel21, javax.swing.GroupLayout.DEFAULT_SIZE, 911, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jLabel21, javax.swing.GroupLayout.PREFERRED_SIZE, 617, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jMenu1.setText("File");

        mAbrir.setText("Abrir");
        mAbrir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mAbrirActionPerformed(evt);
            }
        });
        jMenu1.add(mAbrir);

        jMenuItem2.setText("Salir");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        jMenu3.setText("Imagenes");

        miPixelar.setText("Pixelar");
        miPixelar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miPixelarActionPerformed(evt);
            }
        });
        jMenu3.add(miPixelar);

        Sectorizar.setText("Sectorizar");
        Sectorizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SectorizarActionPerformed(evt);
            }
        });
        jMenu3.add(Sectorizar);

        miEscalaGrises.setText("Escala de grises");
        miEscalaGrises.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miEscalaGrisesActionPerformed(evt);
            }
        });
        jMenu3.add(miEscalaGrises);

        jMenuBar1.add(jMenu3);

        jMenu7.setText("Help");
        jMenuBar1.add(jMenu7);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    
    
    
    
// Menu Item miCargarImagenActionPerformed
    JFileChooser fc;
    public static String ImagePath, archivosPath= "C:/JAVA/IMAGENES/copiaBeta1.14/Prueba de Pixelado.png";
    FileNameExtensionFilter filter;
    public static int nDePix, result;
    File selectedFile;
    public static ImageIcon MI;
    public static Image img;
    
    public static int anchoI, altoI, anchoL, altoL, c, f;
    public static float fE, tgL, tgI, and, ald;
    public static Image newImg;        
    public static ImageIcon image;
    
    public static InputStream input;
    static BufferedImage imagenAx, imagenAxGris;
    static BufferedImage imageL;
    
    
/////////////////////////////////////////   
 
    //
    ///////////////////////////////////////////////////////////////////////////
    //
    
    
    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        // TODO add your handling code here:
        System.exit(0);
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    public static int aristaPixel;
       
    static int Cr, Cg, Cb; 
    
    static int totClas;
    
    static int promGris;
    
    private void mAbrirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mAbrirActionPerformed
        // TODO add your handling code here:
    try {
         
        fc = new JFileChooser();
        // asignamos un título a la ventana que se abrirá
        fc.setDialogTitle("Buscar Imagen");
        
        //File ruta = new File("C:/Users/gabest/Pictures");
        fc.setCurrentDirectory(ruta);

        filter = new FileNameExtensionFilter("*.Images","jpeg","jpg","gif","png","bmp");
        fc.addChoosableFileFilter(filter);
        
        // abre el cuadro de diálogo para elegir el archivo
        result = fc.showSaveDialog(this); // en Work era null);
        
        // ¿Esto es verdad si cierro fileChooser con aceptar?
        if(result==JFileChooser.APPROVE_OPTION)
        {
            
//          recupera el Path del archivo seleccionado por JFileChooser  
            selectedFile = fc.getSelectedFile();
            ImagePath = selectedFile.getAbsolutePath();

//          BIEN jTextField1.setText(extens);
            txtNombreArchivo.setText(ImagePath);//extens);
            
            MI = new ImageIcon(ImagePath);
            img = MI.getImage();
            
            anchoI= MI.getIconWidth();//etiqueta.getHeight();
            altoI= MI.getIconHeight();
            
            jTextField2.setText(String.valueOf(anchoI));
            jTextField3.setText(String.valueOf(altoI));

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

            anchoL=jLabel21.getWidth();
            altoL=jLabel21.getHeight();           
            
            nDePix= altoI*anchoI;
            txtTotPix.setText(String.valueOf(nDePix));
            
            tgL = (float)altoL/(float)anchoL;
            tgI = (float)altoI/(float)anchoI;
            
            if (tgL >= tgI)
            {
                fE= (float)anchoL/(float)anchoI;
            }
            else
            {
                fE= (float)altoL/(float)altoI;
            }
            
            and= (float)0.9*(fE*(float)anchoI);
            ald= (float)0.9*(fE*(float)altoI);

            newImg = img.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
            image = new ImageIcon(newImg);
            
// centrar la imagen que parecerá en el label
            jLabel21.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
            jLabel21.setVerticalAlignment(javax.swing.SwingConstants.CENTER);           
            jLabel21.setIcon(image);
///////////////////////////////////////////////////////////           
// crear la imagen copia en "Prueba de Pixelado"

            fichero = new File("Prueba de Pixelado.png");
            formato = "png";

// Creamos la imagen para dibujar en ella.
            imagenAx = new BufferedImage(anchoI, altoI, BufferedImage.TYPE_INT_RGB);

// Completamos cada pixel
            //int colour;
            //
            input= new FileInputStream(ImagePath);
            imageInput = ImageIO.createImageInputStream(input);// input
            imageL= ImageIO.read(imageInput);

            
            
            for (f=0; f<altoI;f++)
                for (c=0; c<anchoI;c++)
                {
                    //colour= imageL.getRGB(c,f);
                    imagenAx.setRGB(c, f, imageL.getRGB(c,f));
                }
            
            ImageIO.write(imagenAx, formato, fichero);
// crear copia de la imagen
                                
        }
        
        } catch (IOException e) {
            System.out.println("Error de escritura");
        }
            
        
    }//GEN-LAST:event_mAbrirActionPerformed

    
    static int fR, cR;
    
    public static void miaResetearOriginal() {                                                    
        
        // crear la imagen copia en "Prueba de Pixelado"
        // recontruye imagenAx desde la original imageL
        
    try {
         
        fichero = new File("Prueba de Pixelado.png");
        formato = "png";
            
        for (fR=0; fR<altoI;fR++)
            for (cR=0; cR<anchoI;cR++)
            {
                //colour= imageL.getRGB(c,f);
                imagenAx.setRGB(cR, fR, imageL.getRGB(cR,fR));
            }
            
        ImageIO.write(imagenAx, formato, fichero);

// crear copia de la imagen

        jLabel21.setIcon(image);
                                
        } catch (IOException e) {
            System.out.println("Error de escritura");
        }
     
        
    }                                                   

    
    
    private void miPixelarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miPixelarActionPerformed
        // TODO add your handling code here:
        jDialogPixelar frmPix= new jDialogPixelar(this, true);
        //escritorio.add(frm);
        frmPix.toFront();
        frmPix.setVisible(true);
        
    }//GEN-LAST:event_miPixelarActionPerformed

    private void miEscalaGrisesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miEscalaGrisesActionPerformed
        // TODO add your handling code here:
          jDlgEscalaGrises frm= new jDlgEscalaGrises(this, true);
        //escritorio.add(frm);
        frm.toFront();
        frm.setVisible(true);
    }
    
    
    public static void miEscalaDeGrises ()
    {     
        try {    
            // crear la imagen copia en "Prueba de Pixelado"

            ficheroGris = new File("Prueba de Pixelado Gris.png");
            //formato = "png";

            // Creamos la imagen para dibujar en ella.
            imagenAxGris = new BufferedImage(anchoI, altoI, BufferedImage.TYPE_INT_RGB);

            // Completamos cada pixel

            for (f=0; f<altoI;f++)
                for (c=0; c<anchoI;c++)
                {
                    //colour= imagenAx.getRGB(c,f);
                    colorRGBmPix = imagenAx.getRGB(c,f);

                    red= new Color(colorRGBmPix).getRed();
                    green= new Color(colorRGBmPix).getGreen();
                    blue= new Color(colorRGBmPix).getBlue();

                    promGris= (red+green+blue)/3;

                    color= new Color(promGris, promGris, promGris).getRGB();

                    imagenAxGris.setRGB(c, f, color);

                }

            ImageIO.write(imagenAxGris, formato, ficheroGris);

            // HACER EL ICON GRIS
            // PRESENTAR EL ICON GRIS EN EL LABEL PRINCIPAL

            MI1 = new ImageIcon("C:/JAVA/IMAGENES/copiaBeta1.14/Prueba de Pixelado Gris.png");
            img1 = MI1.getImage();
            newImg1 = img1.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
            image1 = new ImageIcon(newImg1);           
            jLabel21.setIcon(image1);

        } catch (IOException e) {
            System.out.println("Error de escritura");
        }
    }//GEN-LAST:event_miEscalaGrisesActionPerformed

    private void SectorizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SectorizarActionPerformed
        // TODO add your handling code here:
       
        JDialogSectorizar frmSect= new JDialogSectorizar(this, true);
        //escritorio.add(frm);
        frmSect.toFront();
        frmSect.setVisible(true); 
        
        
    }//GEN-LAST:event_SectorizarActionPerformed




    static int claseVer;
    static int color, orden, indL;
    

/////////////////////////////////////////////////////////////////////////////
// METODO miPixelarAux
    
static long TIni1, TIni2, TIni3, TIni4, TIni5, TFin1, TFin2, TFin3, TFin4, TFin5;
static long t1, t2, t3, t4, t5; //Variables para determinar el tiempo de ejecución
static int altoIB, anchoIB, xim, yim, ind, k, i, j;    
static float  porcentual;


public static ArrayList <ConjuntoV> listas;//= new ArrayList(); // línea 534

static ImageInputStream imageInput;

static int colorRGBmPix;
static DotFC dFC;
public static ConjuntoV neoListaV;

// ordenamiento
//static ArrayList <ListOrd> listaOrdenada;
//static ListOrd auxPar;

static int maxV, ymaxI, y, xordI;
static boolean maxE;
static int limite, grafClase, tn;

public static float porcent;

public static WorkOnIt trabajo; 

public static int red;
public static int green;
public static int blue;
            
public static int bRed;
public static int bGreen;
public static int bBlue;

public static int colour;
public static int Cr1, Cg1, Cb1;
public static long TInicio, TFin, tiempo; //Variables para determinar el tiempo de ejecución
    
static BufferedImage imageLmP;    // copia de la original imageL    

    /**
     *
     */
    @SuppressWarnings("empty-statement")

//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////// PIXELAR  /////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

public static void miPixelarAux ()
{

        TIni1 = System.currentTimeMillis(); //Tomamos la hora en que inicio el algoritmo y la almacenamos en la variable inicio

        listas= new ArrayList();
  
        try {

            // Leer el archivo Imagen
            input = new FileInputStream(archivosPath);
            imageInput = ImageIO.createImageInputStream(input);
            imageLmP = ImageIO.read(imageInput);
            altoIB = imageLmP.getHeight();
            anchoIB = imageLmP.getWidth();
            //JOptionPane.showMessageDialog(null, "alto y ncho IB " + anchoIB+ "  "+ altoIB);     

        }catch (IOException e){ };
    
        TInicio = System.currentTimeMillis(); //Tomamos la hora en que inicio el algoritmo y la almacenamos en la variable inicio

        xim= 0;
        yim= 0;
            
        // CREO LAS CLASES DE COLOR Y SUS LISTAS DE VÉRTICES
        // comienzo a clasificar
        while (yim<altoIB)
        {
            // leer pixel x,y de la imagen en código entero
            colorRGBmPix = imageLmP.getRGB(xim,yim);
            //obtengo coordenadas RGB de colorRGBPix
 
            red= new Color(colorRGBmPix).getRed();
            green= new Color(colorRGBmPix).getGreen();
            blue= new Color(colorRGBmPix).getBlue();
            
            bRed= (int)(red/aristaPixel)*aristaPixel;
            bGreen= (int)(green/aristaPixel)*aristaPixel;
            bBlue= (int)(blue/aristaPixel)*aristaPixel;
            
            // color base de la clase   
            if(bRed>255) bRed=255;
            if(bGreen>255) bGreen=255;
            if(bBlue>255) bBlue=255;
                
            // calculo el entero que representa la clase
            colorRGBmPix = new Color(bRed, bGreen, bBlue).getRGB();

            ind= -1;
                                       
            for (k=0; k<listas.size(); k++)
                if( listas.get(k).colorClase==colorRGBmPix)
                {
                    ind= k;
                    break;
                }

            dFC= new DotFC(xim, yim);

            if(ind!=-1)
            {
                // -> hay una CtoV listaV con indice ind que tiene el color colorRGB
                //agrego xim, yim a la lista de la categoría
                listas.get(ind).agregarDotFC(dFC);
                //sumo los colores individuales
                listas.get(k).cR=listas.get(k).cR+red;
                listas.get(k).cG=listas.get(k).cG+green;
                listas.get(k).cB=listas.get(k).cB+blue;              
 
            }
            else
            {
                // <- el color aún no ha sido clasificado
                //creo nueva clase ConjuntoV con colorRGB   public static ConjuntoV neoListaV;
                neoListaV= new ConjuntoV(colorRGBmPix);//public static ConjuntoV neoListaV;
                // le agrego el vértice
                neoListaV.agregarDotFC(dFC);
                //sumo los colores individuales
                //neoListaV.agregarDotColor((float)red, (float)green, (float)blue);
                neoListaV.cR= red;
                neoListaV.cG= green;
                neoListaV.cB= blue;
                
                //agrego el nuevo ConjuntoV a la lista principal
                listas.add(neoListaV);
            }

            // avanzo en xim
            if(xim<(anchoIB-1))
            {
                xim++;
            }
            else
            {
                xim= 0;
                yim++;
            }
        }
        
        // calcular promedios
        for (k=0; k<listas.size(); k++)
        {
            tn= listas.get(k).listaV.size();
            listas.get(k).cR=listas.get(k).cR/tn;
            listas.get(k).cG=listas.get(k).cG/tn;
            listas.get(k).cB=listas.get(k).cB/tn;              
        }
        
// CLASES DE COLOR COMPLETAS
//////////////////////////////////////////////////////////////////////////

//  Crear nueva imagen
    
    for (f=0; f<listas.size();f++)
    {
        Cr1=(int)listas.get(f).cR;
        Cg1=(int)listas.get(f).cG;
        Cb1=(int)listas.get(f).cB;
        colour= new Color(Cr1, Cg1, Cb1).getRGB();
        for (c=0; c<listas.get(f).listaV.size();c++)
        {
            x1= listas.get(f).listaV.get(c).cx;
            y1= listas.get(f).listaV.get(c).fy;
            imagenAx.setRGB(x1, y1, colour);
        }
    } 
    
    TFin = System.currentTimeMillis(); //Tomamos la hora en que finalizó el algoritmo y la almacenamos en la variable T
    tiempo = (TFin - TInicio);///1000; //Calculamos los milisegundos de diferencia

    fichero = new File("Prueba de Pixelado.png");
    formato = "png";
    try {
           //}catch (IOException e){ };            
           ImageIO.write(imagenAx, formato, fichero);      

    }catch (IOException e){ };         

}    

    
public static int x1, y1, y2, colorLista,rr, gg, bb, totPix, ordenLista;
static File fichero, ficheroGris;
static String formato;


static ImageIcon MI1;
static Image img1;
static Image newImg1;
static ImageIcon image1;   



public static void presentarClaseColor(int indLista, int ordLista, ArrayList <ConjuntoV> listaspCC )
{
    
    fichero = new File(archivosPath);
    formato = "png";
// Creamos la imagen para dibujar en ella.
    imagenAx = new BufferedImage(anchoIB, altoIB, BufferedImage.TYPE_INT_RGB);
// Hacemos el dibujo
           
    rr=(int)listaspCC.get(indLista).cR;
    gg=(int)listaspCC.get(indLista).cG;
    bb=(int)listaspCC.get(indLista).cB;
    colorLista= new Color(rr, gg, bb).getRGB();
   
            
    // poner imagen en blanco
    
    for (y1=0; y1<altoIB; y1++)
        for (x1=0; x1<anchoIB; x1++)
            imagenAx.setRGB(x1, y1, -1);
    
    totPix= altoIB*anchoIB;
            
 
    // pintar solo los elementos de la clase
    for (y2=0; y2<ordLista; y2++)
    {
        x1= listaspCC.get(indLista).listaV.get(y2).cx;
        y1= listaspCC.get(indLista).listaV.get(y2).fy;
        imagenAx.setRGB(x1, y1, colorLista);
    }

    // Escribimos la imagen en el archivo.
    try {
                
        ImageIO.write(imagenAx, formato, fichero);
                                
        MI1 = new ImageIcon(archivosPath);
        img1 = MI1.getImage();
        newImg1 = img1.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
        image1 = new ImageIcon(newImg1);           
        jLabel21.setIcon(image1);
 
        } catch (IOException e) {
            System.out.println("Error de escritura");
        }

}
  

// definir como argumentos puntero al conjunto de color, puntero al sector
public static void presentarCtoColorSector(int ColAct, int SectAct )
{
    
    
    fichero = new File("Prueba de Pixelado.png");
    formato = "png";
// Creamos la imagen para dibujar en ella.
    imagenAx = new BufferedImage(anchoIB, altoIB, BufferedImage.TYPE_INT_RGB);
 
// poner imagen en blanco
    for (y1=0; y1<altoIB; y1++)
        for (x1=0; x1<anchoIB; x1++)
            imagenAx.setRGB(x1, y1, -1);
        
// Hacemos el dibujo    
// recuperamos el color del conjunto
    colorLista= listasS.get(ColAct).Color;
    
// pintar solo los elementos de la clase
    ordenLista= listasS.get(ColAct).Sectores.get(SectAct).VerticesDelSr.size();
    for (y2=0; y2<ordenLista; y2++)
    {
        x1= listasS.get(ColAct).Sectores.get(SectAct).VerticesDelSr.get(y2).v.cx;
        y1= listasS.get(ColAct).Sectores.get(SectAct).VerticesDelSr.get(y2).v.fy;
        imagenAx.setRGB(x1, y1, colorLista);
    }

// identificamos el sector, comienzo y orden
// por cada vértice del sector, pinto el color del cto en la posición



// presentamos el resultado
// Escribimos la imagen en el archivo.
    try {
                
        ImageIO.write(imagenAx, formato, fichero);
                                
        MI1 = new ImageIcon(archivosPath);
        img1 = MI1.getImage();
        newImg1 = img1.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
        image1 = new ImageIcon(newImg1);           
        jLabel21.setIcon(image1);
 
    } catch (IOException e) {
        System.out.println("Error de escritura");
    }

}

public static int ordSect, is;
public static void presentarCtoColor(int ColAct )
{
  
    fichero = new File("Prueba de Pixelado.png");
    formato = "png";
    // Creamos la imagen para dibujar en ella.
    imagenAx = new BufferedImage(anchoIB, altoIB, BufferedImage.TYPE_INT_RGB);
 
    // poner imagen en blanco
    for (y1=0; y1<altoIB; y1++)
        for (x1=0; x1<anchoIB; x1++)
            imagenAx.setRGB(x1, y1, -1);
        
    // Hacemos el dibujo    
    // recuperamos el color del conjunto
    colorLista= listasS.get(ColAct).Color;
    
    // pintar solo los elementos de la clase
    ordenLista= listasS.get(ColAct).Sectores.size();
    for (y2=0; y2<ordenLista; y2++)
    {
        ordSect= listasS.get(ColAct).Sectores.get(y2).VerticesDelSr.size();
        for (is=0; is<ordSect; is++)
        {
            x1= listasS.get(ColAct).Sectores.get(y2).VerticesDelSr.get(is).v.cx;
            y1= listasS.get(ColAct).Sectores.get(y2).VerticesDelSr.get(is).v.fy;
            imagenAx.setRGB(x1, y1, colorLista);
        }
    }

    // identificamos el sector, comienzo y orden
    // por cada vértice del sector, pinto el color del cto en la posición

    // presentamos el resultado
    // Escribimos la imagen en el archivo.
    try {
                
        ImageIO.write(imagenAx, formato, fichero);
        MI1 = new ImageIcon(archivosPath);
        img1 = MI1.getImage();
        newImg1 = img1.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
        image1 = new ImageIcon(newImg1);           
        jLabel21.setIcon(image1);
 
    } catch (IOException e) {
        System.out.println("Error de escritura");
    }

}

    
//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////// SECTORIZAR  /////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

public static ArrayList <CtoColor> listasS;
public static CtoColor PuntAColor; 
public static ClSector PuntASector;

public static DotFC vAux;

public static int imS, jmS, xmS, vXiS, vYiS;

public static ArrayList <DotFC> VVPendientes;
public static VerticeVecinoPendiente vertVP;
public static CtoColor auxCtoColor;
public static ClSector sectorAux;

public static VertDelSec vds, PuntAVertice, contornoAux;
public static PuntACont pvds, LPAux;

//public static ArrayList <EstadoDeVertice> EstadosDeVerticesFila=new ArrayList();
public static ArrayList <ColumnasEE> EDEstados; // Estructura de Estados

public static ColumnasEE CEAux; // FilaEnesimaAux;
//public static FilasEE filaAux;
public static EstadoIJ eIJaux;
static int colorRGBmS, IndColAct, puntAS, puntAVS, IndSectAct, IndVertAct, limSup;//, puntAVertice//, puntASector;

static int colorAux;

// public static ClLigadurasPendientes LigadurasPendientes, LPAux;
public static ArrayList <PuntACont> ALigadurasPendientes;


    /**
     *
     */
    @SuppressWarnings("empty-statement")
    public static void miSectorizarAux ()
    {    

// CLASES DE COLOR EN: listas de ConjuntoV { int colorClase, cR, cG, cB /  listaV  array de DotFC { int x, y}} 
//                     cantidad de listas=   listas.size()
//                     cantidad de vértices de cada lista=   listas.get(grafClase).listaV.size()
// Tamaño de la imagen   anchoI, altoI
    
    listasS=new ArrayList();
    
    int cx, fy;      
            
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Leer  Imagen preliminar:  Lee el archivo Prueba de Pixelado
    try {
        
            // Leer el archivo Imagen
            input = new FileInputStream(archivosPath);
            imageInput = ImageIO.createImageInputStream(input);
            imageLmP = ImageIO.read(imageInput);
            altoIB = imageLmP.getHeight();
            anchoIB = imageLmP.getWidth();
            
        }catch (IOException e){ };  

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Crear Estructura de Estados e inicializarla en "n" de no visitados
// visitados = "v",   no visitados = "n", pendientes = "p", como vecino actual = "a", como vértice de contorno "c"
    EDEstados= new ArrayList();        

    for (imS=0; imS<anchoIB; imS++)
    {
        CEAux= new ColumnasEE();
        for (jmS=0; jmS<altoIB; jmS++)
        {
            eIJaux= new EstadoIJ();
            eIJaux.EIJn();
            CEAux.ColumnaEnesima.add(eIJaux); 
        }
        EDEstados.add(CEAux); //FEAux);
    } 
    
///////////////////////////////////////////////////////////////////////////////////////////////////    
    // crear Array de vértices Vecinos Pendientes VVPendientes
    // inicializar con un primer elemento 0, 0
    VVPendientes= new ArrayList();
    VVPendientes.add(new DotFC(0,0));

    TInicio = System.currentTimeMillis(); //Tomamos la hora en que inicio el algoritmo y la almacenamos en la variable inicio

///////////////////////////////////////////////////////////////////////////////////////////////////
// llego aca: en el arranque del programa y cuando se vacía ClVecinosActuales (que es ClVecinosActuales actuales)
// Mientras el arreglo de vértices ClVecinosActuales pendientes no esté vacío
    while (!VVPendientes.isEmpty())
    {

        ///////////////////////////////////////////////////////////////////////
        // leo el primér vértive en ClVecinosActuales pendientes
        // este se procesa por comopleto aca
        //
        //      En un color actual: crea nuevo sector y su contorno 
        //      o
        //      crea nuevo color, nuevo sector y nuevo contorno
        
        
        vAux=VVPendientes.get(0);   // es un DotFC
 
////////////////////////////////////////////////////////////////////////
        //  ACTUALIZO LISTASS
        
        // recuperar color del vértice vAux
        colorAux= imageLmP.getRGB(vAux.cx,vAux.fy);
        


        // veo si el color ya esta definido en la lista de sectores listasS
        // Ubico el puntero al color o creo uno nuevo
        
        limSup= listasS.size();
        for (imS= 0; imS<limSup; imS++)
            if (colorAux==listasS.get(imS).Color)
            {
                PuntAColor= listasS.get(imS);
                imS= limSup + 1;
            }

        // si el color no esta definido...
        if ( imS==limSup ) //PuntAColor==null )
        {
            // el color no esta en la lista aún
            // creo registro auxCtoColor
            // anoto el color
            auxCtoColor= new CtoColor();
            auxCtoColor.addColorCtoColor(colorAux);
            // lo agrego a la lista
            
            listasS.add(auxCtoColor);
            PuntAColor= listasS.get(listasS.size()-1);
        }

// Aca tengo 
//              vAux   vértice principal que inicia el sector del color ColorAux y será padre.
//              ColorAux  el color de un nuevo sector en listasS, apuntado por PuntAColor 
//              PuntAColor,   puntero que apunta a este color. Nunca es NULL, apunta a un color ya creado o a uno nuevo
//              listasS en el color ColorAux es equivalente a PuntAColor

////////////////////////////////////////////////////////////////////////////////////////////////////////

        // debo crear un sector en ella con el vértice actual  vAux
        //      creo un sector aux
        //      agrego el vértice vAux
        //      adjunto el sector a la clase de color en  listasS.get(puntAColor).Sectores.add(sectorAux)
        //

        // sectorAux es ClSector
        sectorAux= new ClSector();
                
        vds= new VertDelSec();
        vds.VertDelSecAddV(vAux);
        sectorAux.AgregarVDS(vds);//.VerticesDelSr.add(vds);


/////////////
/*
        // crear el puntero de contorno y enlazarlo con el vértice del sector
        pvds= new PuntACont();
        pvds.pavs= sectorAux.VerticesDelSr.get(sectorAux.VerticesDelSr.size()-1);
        sectorAux.Contorno.add(pvds);
*/       
       

        // agrego el sector a la lista
        PuntAColor.Sectores.add(sectorAux);
        

/*
        // necesito la normal del vértice de contorno
        
////////////////////////////////////////////////////////////////////////
////  crear la LigaduraPendiente y enlazarla con el correspondiente de contorno
        
        ALigadurasPendientes= new ArrayList();
        LPAux= new PuntACont();
        LPAux = sectorAux.Contorno.get(sectorAux.Contorno.size()-1);
        ALigadurasPendientes.add(LPAux);
        sectorAux.Contorno.get(sectorAux.Contorno.size()-1).ligPend= ALigadurasPendientes.get(ALigadurasPendientes.size()-1);
 
*/
      
////////////////////////////////////////////////////////////////////////
//  ACTUALIZO ESTRUCTURA DE ESTADOS
//
//  ¿EN QUE LUGARES USO LOS SIGUIENTES TRES ELEMENTOS?


        //  marco vAux como visitado C en Estructuras de estados
        EDEstados.get(vAux.cx).ColumnaEnesima.get(vAux.fy).EIJv();// .estado= "c";, de "contorno"

        //apunto al sector desde la estructura de Estados
        EDEstados.get(vAux.cx).ColumnaEnesima.get(vAux.fy).punteroS.indAColor= PuntAColor;
        
        // definir puntASector
        PuntASector= PuntAColor.Sectores.get(PuntAColor.Sectores.size()-1);
        EDEstados.get(vAux.cx).ColumnaEnesima.get(vAux.fy).punteroS.indASector= PuntASector;
         
 
 ////////////////////////////////////////////////////////////////////////
 // a completar clase de sector del vértice vds  o  vAux
 
 // aquí se de vAux:    crea un nuevo sector del color actual
 //                     es de contorno
 
        CompletarClaseDeSector (vds); //vAux);
        

// elimino el primer vértice leido
        VVPendientes.remove(0);

    }

    TFin = System.currentTimeMillis(); //Tomamos la hora en que finalizó el algoritmo y la almacenamos en la variable T
    tiempo = (TFin - TInicio);///1000; //Calculamos los milisegundos de diferencia

}


           

public static DotFC vertA;
public static DotFC vertA1, padreA1;
public static PuntACont pvds1;

static int NuevoVectorCecinoPendiente;
static VerticeVecinoPendiente vertVP1;
static ArrayList <ClVecinosActuales> VecinosActuales;



public static VertDelSec vds1, PuntAVertice1;
// recivo  vert   que crea un nuevo sector

public static void CompletarClaseDeSector (VertDelSec vertS)
{

    String EstActVA1= new String();
    int PosUltPend, i, cx, fy;        
    DotFC PosVVP, PuntActEDEVA1;
    
 
// vertS    inicia sector y es de contorno
    VecinosActuales= new ArrayList();
    adjuntarVecinosActuales(vertS);
            
    // creo el arreglo ClVecinosActuales
    // ClVecinosActuales= new ArrayList();
    String estadoActual= new String();
    
       
    // tengo todos los ClVecinosActuales vert en ClVecinosActuales, escritos en sentido horario comenzando por 0,0
    while (!VecinosActuales.isEmpty())
    {

        // leer el primer vértice    get(i)
        vertA1= VecinosActuales.get(0).vert; //new DotFC(ClVecinosActuales.get(0).cx, ClVecinosActuales.get(0).fy);
        padreA1= VecinosActuales.get(0).padre;
        
        vds1= new VertDelSec();
        //PuntAVertice1= new VertDelSec();
    
        // agrego el vértice al sector actual
        //sectorAux= new ClSector();  
        vds1.VertDelSecAddV(vertA1);
        PuntASector.AgregarVDS(vds1);//.VerticesDelSr.add(vds1);
        
        
// si es de contorno, lo debo agregar a contorno, sino (else) lo agrego al sector normalmente
/*          
        // si vert es del borde/contorno de la imagen, entonces vert es contorno de sector
        if (vertA1.cx==0 || vertA1.cx==anchoIB-1 || vertA1.fy==0 || vertA1.fy==altoIB-1)
        {
            
            //PuntAVertice1= PuntASector.VerticesDelSr.get(PuntASector.VerticesDelSr.size()-1);
            
            
            // pertenece al contorno
            // ->   if no está anotado como de contorno
            //          desde la def de vert  en listasS.Sectores.VerticesDelSec  apuntar al próximo lugar de contorno
            //          desde  el nuevo lugar en contorno, apuntar al anterior vert
            //          ¿queda por hacerse algo en EEstados?
            pvds1= new PuntACont();
            //vds.VertDelSecAddV(vAux);
            //sectorAux.AgregarVDS(vds);//.VerticesDelSr.add(vds);
            pvds1.pavs= sectorAux.VerticesDelSr.get(sectorAux.VerticesDelSr.size()-1);
            //sectorAux.Contorno.add(pvds1);   
            
            PuntASector.Contorno.add(pvds1);
            PuntASector.VerticesDelSr.get(PuntASector.VerticesDelSr.size()-1).pc= PuntASector.Contorno.get(PuntASector.Contorno.size()-1);
            EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).EIJc();  
        }            
        else
  */
        {            
            // lo marco como visitado en la estructura de estados
            EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).EIJv();  //.estado= "v"; 
        }
            
        // actualizo punteros en Estructura de estados
        EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).punteroS.indAColor= PuntAColor;
        // definir puntASector
        EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).punteroS.indASector= PuntASector;
        //definir puntAVertice
        EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).punteroS.indAVertice= PuntAVertice1; // puntAVertice;
 
        // si vertA1 esta en VVP hay que retirarlo
        PosVVP= EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).punteroS.indAVVP;
                        
        if ( PosVVP != null )
        {
            VVPendientes.remove(PosVVP);
            EDEstados.get(vertA1.cx).ColumnaEnesima.get(vertA1.fy).punteroS.indAVVP= null;
        }
            
        VecinosActuales.remove(0);    
        adjuntarVecinosActuales(vds1);
        
       
        
    }

}
  


//  ImgPrincipal114.colorAux    color de referencia
public static void adjuntarVecinosActuales( VertDelSec vds )
{
    
    
    int ncolor;
    DotFC vert= new DotFC(vds.v);
    
    
 /*   
    if (vert.cx > 0 && vert.fy > 0 )
 */ 
    //   if ( vert.fy >= 0 )
    {
        DotFC nvert= new DotFC();
        
        nvert.cx= vert.cx;
        nvert.fy= vert.fy-1;
        
        EvaluarVertYNvert (vert, nvert, vds);
        
    }////

/*  
    if (vert.cx < anchoIB-1 && vert.fy > 0 )
*/

//    if (vert.cx <= anchoIB-1 )
    {
        DotFC nvert= new DotFC();
        
        nvert.cx= vert.cx+1;
        nvert.fy= vert.fy;
        
        EvaluarVertYNvert (vert, nvert, vds);
        
     }
////

/*
    if (vert.cx < anchoIB-1 && vert.fy < altoIB-1 )
*/

//    if ( vert.fy <= altoIB-1 )
    {
        DotFC nvert= new DotFC();
        nvert.cx= vert.cx;
        nvert.fy= vert.fy+1;
        
        EvaluarVertYNvert (vert, nvert, vds);
        
    }////

/*    
    if (vert.cx > 0 && vert.fy < altoIB-1 )
*/

//    if (vert.cx >= 0 )
    {
        DotFC nvert= new DotFC();
        nvert.cx= vert.cx-1;
        nvert.fy= vert.fy;
        
        EvaluarVertYNvert (vert, nvert, vds);
        
    }////
    

}        





public static PuntACont pac;

// Evalúa si el los vecinos NVERT de VERT pertenecen o no al sector

static public void EvaluarVertYNvert (DotFC vert, DotFC nvert, VertDelSec vds)
{
    
    DotFC PosVVP;
    int nvertcolor;
    
    // si nvert es negativo, anchoIB-1 && vert.fy < altoIB-1
    if ( nvert.cx<0 || nvert.fy<0 || nvert.cx==anchoIB || nvert.fy==altoIB )
    {
        // -> si aún no está declarado, declaro vert de contorno
        if (EDEstados.get(vert.cx).ColumnaEnesima.get(vert.fy).estado != "c")
        {
            //      anotarlo como contorno vidireccional
            pac= new PuntACont();
            pac.pavs= vds;

            PuntAColor.Sectores.get(PuntAColor.Sectores.size()-1).Contorno.add(pac);
            ////////////////////////////////////////////////////////////////////////
            //  ACTUALIZO ESTRUCTURA DE ESTADOS

            //  marco vAux como visitado C en Estructuras de estados
            EDEstados.get(vert.cx).ColumnaEnesima.get(vert.fy).EIJc();// .estado= "v";

        }
        
        //    calculo una NORMAL con nvert
        
    }
    else
    { 
    //    calcular color de nvert...  
        nvertcolor= imageLmP.getRGB(nvert.cx,nvert.fy);
    
        // si nvertcolor, color de nver es el del sector, entonces nvert, pertenece al sector
        if ( ImgPrincipal114.colorAux==nvertcolor )
        {   
            //if(!EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado.equals("v") && !EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado.equals("a"))// || EDEstados.get(vertA.cx).ColumnaEnesima.get(vertA.fy).estado.equals("p"))
            if(EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado.equals("n") || EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado.equals("p"))// || EDEstados.get(vertA.cx).ColumnaEnesima.get(vertA.fy).estado.equals("p"))
            {
                VecinosActualesAdd(new DotFC(nvert.cx, nvert.fy), new DotFC(vert.cx, vert.fy));
                if(EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado.equals("p"))// || EDEstados.get(vertA.cx).ColumnaEnesima.get(vertA.fy).estado.equals("p"))
                {
                    // hay que sacarlo de VVPendientes
                    PosVVP= EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).punteroS.indAVVP;

                    if ( PosVVP != null )
                    {
                        VVPendientes.remove(PosVVP);
                        EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).punteroS.indAVVP= null;
                    }            
                }

                EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).EIJa();

            }
        }
        else  // va a vecinos pendientes y se resuelve un vertice de contorno
        {
            // vert es de contorno
            //    si no está declarado como contorno, declaro vert de contorno
            //    calculo una NORMAL con nvert
            
            // if vert no esta anotado aún como contorno
            if (EDEstados.get(vert.cx).ColumnaEnesima.get(vert.fy).estado != "c")
            {
                //      anotarlo como contorno vidireccional
                pac= new PuntACont();
                pac.pavs= vds;

                PuntAColor.Sectores.get(PuntAColor.Sectores.size()-1).Contorno.add(pac);
                ////////////////////////////////////////////////////////////////////////
                //  ACTUALIZO ESTRUCTURA DE ESTADOS

                //  marco vAux como visitado C en Estructuras de estados
                EDEstados.get(vert.cx).ColumnaEnesima.get(vert.fy).EIJc();// .estado= "v";

            }
            
            // Hay que agregar una NORMAL para vert, con nvert
            
            
            // nvert y su color van a vertices pendientes
            // si nvert no está en VVPendientes se lo agrega
            if( EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).estado == "n" )
            {
                VVPendientes.add(new DotFC(nvert));
                EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).EIJp();
                EDEstados.get(nvert.cx).ColumnaEnesima.get(nvert.fy).punteroS.indAVVP= VVPendientes.get(VVPendientes.size()-1);
            }   
        }
    }

}


public static void VecinosActualesAdd( DotFC vert, DotFC padre)
{
    // definir un ClVecinosActuales con puntero ApuntPor null
    ClVecinosActuales nva= new ClVecinosActuales();
    
    // copiar el vértice vert
    nva.vert.cx= vert.cx;
    nva.vert.fy= vert.fy;
    
    nva.padre.cx= padre.cx;
    nva.padre.fy= padre.fy;
    
    // adjuntar al arreglo
    VecinosActuales.add(nva);
       
}
        

public static DotFC normal;

public static void ObtenerNormal (DotFC vertP, DotFC vertE)
{
    
    if (vertE==null)
    {
        if (vertP.cx==0)
        {
            normal.cx= -1;
            normal.fy= 0;
        }
        else if (vertP.fy==0)
        {
            normal.cx= 0;
            normal.fy= -1;
        }
    }
    else
    {
        
    }
    
}
    
public static File ficheroContornos;
public static BufferedImage imagenAxContornos;
public static int ic, jc, zc, cantVert, cantVertC, cantCol, cSecCol, vCol, vcx, vfy;
public static float filtroC, factorF;  
    
public static void miVerContornos ()
{     
    try {
        
        // crear la imagen copia en "Prueba de Pixelado"

        factorF= 1-filtroC/100;
        
        ficheroContornos = new File("Prueba de Pixelado Contornos.png");

        // Creamos la imagen para dibujar en ella.
        imagenAxContornos = new BufferedImage(anchoIB, altoIB, BufferedImage.TYPE_INT_RGB);
        
        // cantidad de colores
        cantCol= listasS.size();
        
        // por cada color
        for (ic=0; ic<cantCol; ic++)
        {
            vCol= listasS.get(ic).Color;
            cSecCol= listasS.get(ic).Sectores.size();
            // por cada sector del color actual
            for (jc=0; jc<cSecCol; jc++)
            {
                // por cada vértice del sector
                cantVertC= listasS.get(ic).Sectores.get(jc).Contorno.size();
                cantVert= listasS.get(ic).Sectores.get(jc).VerticesDelSr.size();
                if( (float)cantVertC/(float)cantVert < factorF )
                    for (zc=0; zc<cantVertC; zc++)
                    {
                        // marco el vértice cx, fy
                        vcx= listasS.get(ic).Sectores.get(jc).Contorno.get(zc).pavs.v.cx;
                        vfy= listasS.get(ic).Sectores.get(jc).Contorno.get(zc).pavs.v.fy;

                        imagenAxContornos.setRGB(vcx, vfy, vCol);
                    }
            }
        }
        
        // ¿La imagen ya está en blanco?

        ImageIO.write(imagenAxContornos, formato, ficheroContornos);

        // HACER EL ICON GRIS
        // PRESENTAR EL ICON GRIS EN EL LABEL PRINCIPAL

        MI1 = new ImageIcon("C:/JAVA/IMAGENES/copiaBeta1.14/Prueba de Pixelado Contornos.png");
        img1 = MI1.getImage();
        newImg1 = img1.getScaledInstance((int)and, (int)ald, Image.SCALE_DEFAULT);
        image1 = new ImageIcon(newImg1);           
        jLabel21.setIcon(image1);

    } catch (IOException e) {
        System.out.println("Error de escritura");
    }
}     


        
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImgPrincipal114.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImgPrincipal114.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImgPrincipal114.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImgPrincipal114.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new ImgPrincipal114().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem Sectorizar;
    public static javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel11;
    public static javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenu jMenu5;
    private javax.swing.JMenu jMenu6;
    private javax.swing.JMenu jMenu7;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPopupMenu jPopupMenu1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JMenuItem mAbrir;
    private javax.swing.JMenuItem miEscalaGrises;
    private javax.swing.JMenuItem miPixelar;
    private javax.swing.JTextField txtNombreArchivo;
    public static javax.swing.JTextField txtTotPix;
    // End of variables declaration//GEN-END:variables
}
